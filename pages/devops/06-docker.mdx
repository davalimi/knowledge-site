# Docker - La containerisation

`[DEBUTANT]` - Temps: 50 min lecture + 40 min pratique

---

## Why - Pourquoi c'est important

Le probleme classique: "Ca marche sur ma machine!"

**Sans Docker:**
- Dependances differentes entre dev/prod
- Installation complexe sur chaque serveur
- Conflits entre applications
- "Ca marchait avant..."

**Avec Docker:**
- Meme environnement partout
- Deploiement en secondes
- Isolation complete
- Reproductibilite garantie

Docker a revolutionne le DevOps. C'est devenu un standard de l'industrie.

---

## What - C'est quoi

### Analogie: Le container maritime

Avant les containers, charger un bateau etait chaotique. Chaque marchandise avait sa taille, son emballage.

Les containers ont tout standardise: meme taille, meme interface, empilables, transportables par bateau/train/camion.

Docker fait pareil pour les applications: meme format, meme interface, deploie partout.

### Container vs VM

```
┌─────────────────────────────────────────────────────────────┐
│                 CONTAINER vs VM                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  VIRTUAL MACHINE                    CONTAINER               │
│  ───────────────                    ─────────               │
│  ┌─────────────────┐               ┌────────┐ ┌────────┐   │
│  │      App        │               │  App   │ │  App   │   │
│  ├─────────────────┤               ├────────┤ ├────────┤   │
│  │   Guest OS      │               │  Libs  │ │  Libs  │   │
│  ├─────────────────┤               └────────┴─┴────────┘   │
│  │   Hypervisor    │               │    Docker Engine     │ │
│  ├─────────────────┤               ├─────────────────────┤ │
│  │    Host OS      │               │       Host OS        │ │
│  ├─────────────────┤               ├─────────────────────┤ │
│  │   Hardware      │               │      Hardware        │ │
│  └─────────────────┘               └─────────────────────┘ │
│                                                              │
│  - OS complet par VM                - Partage le kernel     │
│  - GB de RAM                        - MB de RAM             │
│  - Minutes au boot                  - Secondes au boot      │
│  - Isolation forte                  - Isolation processus   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Concepts cles

```
┌─────────────────────────────────────────────────────────────┐
│                    CONCEPTS DOCKER                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  IMAGE                                                       │
│  ─────                                                       │
│  - Template read-only                                       │
│  - Contient l'app + deps + configs                          │
│  - Comme un ISO ou snapshot                                 │
│  - Versionnee avec des tags                                 │
│                                                              │
│  CONTAINER                                                   │
│  ─────────                                                   │
│  - Instance runnable d'une image                            │
│  - Isole, avec son propre filesystem/reseau                │
│  - Ephemere par defaut                                      │
│                                                              │
│  DOCKERFILE                                                  │
│  ──────────                                                  │
│  - Script pour construire une image                         │
│  - Instructions: FROM, COPY, RUN, CMD...                   │
│                                                              │
│  REGISTRY                                                    │
│  ────────                                                    │
│  - Depot d'images                                           │
│  - Docker Hub (public), ECR, Nexus (prive)                 │
│                                                              │
│  VOLUME                                                      │
│  ──────                                                      │
│  - Stockage persistant                                      │
│  - Survit a la destruction du container                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## How - En pratique

### Installation

```bash
# Ubuntu/Debian
curl -fsSL https://get.docker.com | sh
sudo usermod -aG docker $USER
# Logout/login pour prendre effet

# Verifier
docker --version
docker run hello-world
```

### Commandes de base

```bash
# === IMAGES ===

# Telecharger une image
docker pull nginx
docker pull nginx:1.25              # Version specifique
docker pull python:3.11-slim        # Variante slim

# Lister les images locales
docker images
docker image ls

# Supprimer une image
docker rmi nginx
docker image rm nginx:1.25
docker image prune                  # Supprimer les images non utilisees

# === CONTAINERS ===

# Lancer un container
docker run nginx                    # Foreground
docker run -d nginx                 # Background (detached)
docker run -d --name web nginx      # Avec un nom
docker run -d -p 8080:80 nginx      # Port mapping
docker run -it ubuntu bash          # Mode interactif

# Lister les containers
docker ps                           # Running
docker ps -a                        # Tous

# Gerer les containers
docker stop web                     # Arreter
docker start web                    # Demarrer
docker restart web                  # Redemarrer
docker rm web                       # Supprimer
docker rm -f web                    # Forcer

# Logs et debug
docker logs web                     # Voir les logs
docker logs -f web                  # Follow
docker logs --tail 100 web          # 100 dernieres lignes
docker exec -it web bash            # Shell dans le container
docker inspect web                  # Details JSON

# Stats
docker stats                        # CPU/RAM en temps reel
docker top web                      # Processus dans le container
```

### Port mapping

```bash
# -p host_port:container_port
docker run -d -p 8080:80 nginx
# → localhost:8080 accede au port 80 du container

# Plusieurs ports
docker run -d -p 8080:80 -p 8443:443 nginx

# Port aleatoire
docker run -d -P nginx              # Ports exposes automatiquement

# Bind sur une IP specifique
docker run -d -p 127.0.0.1:8080:80 nginx  # Seulement localhost
```

### Volumes

```bash
# === BIND MOUNTS (dossier local) ===
docker run -d -v /path/local:/path/container nginx
docker run -d -v $(pwd)/html:/usr/share/nginx/html nginx

# === NAMED VOLUMES (geres par Docker) ===
# Creer un volume
docker volume create mydata

# Utiliser
docker run -d -v mydata:/data nginx

# Lister
docker volume ls

# Inspecter
docker volume inspect mydata

# Supprimer
docker volume rm mydata
docker volume prune                 # Supprimer les orphelins
```

### Variables d'environnement

```bash
# Une variable
docker run -d -e MYSQL_ROOT_PASSWORD=secret mysql

# Plusieurs variables
docker run -d \
  -e MYSQL_ROOT_PASSWORD=secret \
  -e MYSQL_DATABASE=myapp \
  -e MYSQL_USER=user \
  mysql

# Depuis un fichier
cat > .env << EOF
MYSQL_ROOT_PASSWORD=secret
MYSQL_DATABASE=myapp
EOF

docker run -d --env-file .env mysql
```

### Dockerfile

```dockerfile
# Dockerfile basique
FROM python:3.11-slim

# Metadata
LABEL maintainer="ton@email.com"
LABEL version="1.0"

# Variables d'environnement
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Repertoire de travail
WORKDIR /app

# Copier les dependances d'abord (cache layer)
COPY requirements.txt .

# Installer les deps
RUN pip install --no-cache-dir -r requirements.txt

# Copier le code
COPY . .

# Exposer le port
EXPOSE 5000

# Utilisateur non-root (securite)
RUN useradd -m appuser
USER appuser

# Commande par defaut
CMD ["python", "app.py"]
```

### Instructions Dockerfile

```dockerfile
# FROM: Image de base
FROM ubuntu:22.04
FROM python:3.11-slim
FROM node:20-alpine

# RUN: Executer des commandes pendant le build
RUN apt-get update && apt-get install -y nginx
RUN pip install flask

# COPY: Copier des fichiers locaux
COPY app.py /app/
COPY . /app/

# ADD: Comme COPY + extraction d'archives + URLs
ADD https://example.com/file.tar.gz /app/
ADD archive.tar.gz /app/               # Auto-extrait

# WORKDIR: Definir le repertoire de travail
WORKDIR /app

# ENV: Variables d'environnement
ENV NODE_ENV=production
ENV PORT=3000

# EXPOSE: Documenter le port (pas de mapping)
EXPOSE 3000

# USER: Changer d'utilisateur
USER appuser

# CMD: Commande par defaut (peut etre override)
CMD ["node", "index.js"]
CMD ["python", "app.py"]

# ENTRYPOINT: Point d'entree fixe
ENTRYPOINT ["python"]
CMD ["app.py"]                         # Arguments par defaut
# docker run myapp script.py          # Override CMD seulement

# ARG: Variables de build
ARG VERSION=1.0
RUN echo "Building version $VERSION"
# docker build --build-arg VERSION=2.0 .

# HEALTHCHECK: Verification de sante
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
```

### Build une image

```bash
# Build basique
docker build -t myapp .
docker build -t myapp:1.0 .

# Avec un Dockerfile different
docker build -f Dockerfile.prod -t myapp:prod .

# Build arguments
docker build --build-arg VERSION=2.0 -t myapp .

# Sans cache
docker build --no-cache -t myapp .

# Multi-plateforme (arm64, amd64)
docker buildx build --platform linux/amd64,linux/arm64 -t myapp .
```

### Multi-stage builds

```dockerfile
# === Stage 1: Build ===
FROM node:20 AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# === Stage 2: Production ===
FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

Avantages:
- Image finale plus petite (pas de devDependencies)
- Pas d'outils de build en prod
- Plus securise

### Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgres://db:5432/myapp
    depends_on:
      - db
    volumes:
      - ./uploads:/app/uploads
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: myapp
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: myapp
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  pgdata:
```

```bash
# Commandes Compose
docker compose up                   # Lancer
docker compose up -d                # Detached
docker compose up --build           # Rebuild les images
docker compose down                 # Arreter et supprimer
docker compose down -v              # + supprimer volumes
docker compose logs -f              # Logs
docker compose ps                   # Status
docker compose exec web bash        # Shell dans un service
docker compose restart web          # Restart un service
```

### Networking

```bash
# Types de reseaux
docker network ls

# Creer un reseau
docker network create mynet

# Lancer avec un reseau
docker run -d --network mynet --name web nginx
docker run -d --network mynet --name db postgres

# Les containers peuvent se parler par nom
# web → ping db (fonctionne!)

# Connecter un container existant
docker network connect mynet existing-container

# Inspecter
docker network inspect mynet
```

---

## Bonnes pratiques

### Securite

```dockerfile
# 1. Utiliser des images officielles et slim/alpine
FROM python:3.11-slim     # Pas python:3.11

# 2. Ne pas run en root
RUN useradd -m appuser
USER appuser

# 3. Scanner les vulnerabilites
# docker scout quickview myimage

# 4. Pas de secrets dans l'image
# Utiliser des variables d'env ou secrets Docker

# 5. Mettre a jour regulierement
```

### Performance

```dockerfile
# 1. Ordre des instructions (cache)
COPY requirements.txt .       # Change rarement
RUN pip install -r requirements.txt
COPY . .                      # Change souvent

# 2. Combiner les RUN
RUN apt-get update && \
    apt-get install -y nginx curl && \
    rm -rf /var/lib/apt/lists/*

# 3. .dockerignore
# .dockerignore
node_modules
.git
*.log
.env
```

### Image size

```bash
# Comparer les tailles
docker images

# python:3.11          ~1GB
# python:3.11-slim     ~150MB
# python:3.11-alpine   ~50MB

# Utiliser multi-stage builds
# Nettoyer les caches apt/pip dans le meme RUN
```

---

## Practice - Exercices

### Exercice 1: Premier container

```bash
# 1. Lancer nginx
docker run -d -p 8080:80 --name web nginx

# 2. Tester
curl http://localhost:8080

# 3. Modifier le contenu
docker exec -it web bash
echo "Hello Docker!" > /usr/share/nginx/html/index.html
exit
curl http://localhost:8080

# 4. Voir les logs
docker logs web

# 5. Nettoyer
docker rm -f web
```

### Exercice 2: Construire une image

```bash
# 1. Creer l'app
mkdir myapp && cd myapp

cat > app.py << 'EOF'
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello from Docker!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
EOF

cat > requirements.txt << 'EOF'
flask==3.0.0
EOF

# 2. Creer le Dockerfile
cat > Dockerfile << 'EOF'
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]
EOF

# 3. Build
docker build -t myflask .

# 4. Run
docker run -d -p 5000:5000 myflask

# 5. Tester
curl http://localhost:5000
```

### Exercice 3: Docker Compose

```bash
# 1. Creer docker-compose.yml
cat > docker-compose.yml << 'EOF'
version: '3.8'
services:
  app:
    build: .
    ports:
      - "5000:5000"
    environment:
      - REDIS_HOST=redis
    depends_on:
      - redis

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
EOF

# 2. Lancer
docker compose up -d

# 3. Verifier
docker compose ps
docker compose logs

# 4. Arreter
docker compose down
```

---

## Project - Mini-projet

### Projet: App complete containerisee

```bash
# === Structure ===
fullstack-docker/
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   └── src/
├── backend/
│   ├── Dockerfile
│   ├── requirements.txt
│   └── app.py
├── docker-compose.yml
└── .env

# === Backend Flask ===
mkdir -p backend && cd backend

cat > requirements.txt << 'EOF'
flask==3.0.0
flask-cors==4.0.0
redis==5.0.0
EOF

cat > app.py << 'EOF'
from flask import Flask, jsonify
from flask_cors import CORS
import redis
import os

app = Flask(__name__)
CORS(app)

r = redis.Redis(host=os.getenv('REDIS_HOST', 'localhost'))

@app.route('/api/count')
def count():
    count = r.incr('hits')
    return jsonify(count=count)

@app.route('/api/health')
def health():
    return jsonify(status='ok')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
EOF

cat > Dockerfile << 'EOF'
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]
EOF

# === Frontend (simple HTML) ===
cd .. && mkdir -p frontend && cd frontend

cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>Docker Demo</title></head>
<body>
  <h1>Page Views: <span id="count">-</span></h1>
  <script>
    fetch('/api/count')
      .then(r => r.json())
      .then(d => document.getElementById('count').textContent = d.count);
  </script>
</body>
</html>
EOF

cat > nginx.conf << 'EOF'
server {
    listen 80;
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }
    location /api {
        proxy_pass http://backend:5000;
    }
}
EOF

cat > Dockerfile << 'EOF'
FROM nginx:alpine
COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY index.html /usr/share/nginx/html/
EOF

# === Docker Compose ===
cd ..

cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    environment:
      - REDIS_HOST=redis
    depends_on:
      - redis

  redis:
    image: redis:7-alpine
    volumes:
      - redis-data:/data

volumes:
  redis-data:
EOF

# === Lancer ===
docker compose up -d --build

# Ouvrir http://localhost - le compteur s'incremente!
```

---

## Cheatsheet

```
┌─────────────────────────────────────────────────────────────┐
│                        DOCKER                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  IMAGES                                                      │
│  ──────                                                      │
│  docker pull nginx:latest          # Telecharger            │
│  docker build -t myapp .           # Construire             │
│  docker images                     # Lister                 │
│  docker rmi image                  # Supprimer              │
│                                                              │
│  CONTAINERS                                                  │
│  ──────────                                                  │
│  docker run -d -p 8080:80 nginx    # Lancer                 │
│  docker ps                         # Lister running         │
│  docker ps -a                      # Lister tous            │
│  docker stop/start/restart name    # Gerer                  │
│  docker rm name                    # Supprimer              │
│  docker logs -f name               # Logs                   │
│  docker exec -it name bash         # Shell                  │
│                                                              │
│  VOLUMES                                                     │
│  ───────                                                     │
│  docker volume create vol          # Creer                  │
│  docker run -v vol:/data nginx     # Utiliser               │
│  docker run -v $(pwd):/app nginx   # Bind mount             │
│                                                              │
│  NETWORK                                                     │
│  ───────                                                     │
│  docker network create net         # Creer                  │
│  docker run --network net nginx    # Utiliser               │
│                                                              │
│  COMPOSE                                                     │
│  ───────                                                     │
│  docker compose up -d              # Lancer                 │
│  docker compose down               # Arreter                │
│  docker compose logs -f            # Logs                   │
│  docker compose ps                 # Status                 │
│                                                              │
│  DOCKERFILE                                                  │
│  ──────────                                                  │
│  FROM python:3.11-slim             # Image de base          │
│  WORKDIR /app                      # Repertoire             │
│  COPY . .                          # Copier fichiers        │
│  RUN pip install -r req.txt        # Executer               │
│  EXPOSE 5000                       # Port                   │
│  CMD ["python", "app.py"]          # Commande               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Interview Qs - Questions classiques

1. **C'est quoi la difference entre une image et un container?**
   → Image: template read-only. Container: instance runnable d'une image, avec son propre etat.

2. **Difference entre CMD et ENTRYPOINT?**
   → CMD: commande par defaut, peut etre override. ENTRYPOINT: point d'entree fixe, CMD devient ses arguments.

3. **C'est quoi un multi-stage build?**
   → Dockerfile avec plusieurs FROM. Permet de builder dans un stage et copier seulement le necessaire dans l'image finale. Reduit la taille.

4. **Comment persister les donnees d'un container?**
   → Volumes (managed par Docker) ou bind mounts (dossier local). Les donnees survivent a la destruction du container.

5. **Difference entre COPY et ADD?**
   → COPY: copie fichiers locaux. ADD: pareil + extraction auto des archives + telechargement URLs. Preferer COPY.

6. **Comment les containers communiquent entre eux?**
   → Via un network Docker. Les containers sur le meme network peuvent se joindre par leur nom.

---

## Sujets lies

- **Avant:** [Build Tools](/devops/build-tools) - Construire avant de containeriser
- **Avant:** [Nexus](/devops/nexus) - Registry prive pour images
- **Apres:** [Jenkins](/devops/jenkins) - CI/CD avec Docker
- **Apres:** [Kubernetes](/devops/kubernetes) - Orchestration de containers

---

*Temps estime: 50 min lecture + 40 min pratique*
