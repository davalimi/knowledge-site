# Python Fundamentals - Les bases pour le DevOps

`[DEBUTANT]` - Temps: 45 min lecture + 35 min pratique

---

## Why - Pourquoi c'est important

Python est LE langage du DevOps:
- Scripts d'automatisation
- Outils comme Ansible, AWS CLI sont en Python
- APIs et SDKs disponibles
- Simple a apprendre et lire
- Enorme ecosysteme

Si tu veux automatiser, tu dois connaitre Python.

---

## What - C'est quoi

### Analogie: Le couteau suisse

Python c'est comme un couteau suisse pour le DevOps:
- Peut faire presque tout
- Simple a utiliser
- Toujours a portee de main

### Python pour DevOps

```
┌─────────────────────────────────────────────────────────────┐
│                    PYTHON EN DEVOPS                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  AUTOMATISATION                                              │
│  ─────────────                                               │
│  - Scripts de deploiement                                   │
│  - Gestion de fichiers                                      │
│  - Appels API                                               │
│                                                              │
│  OUTILS DEVOPS EN PYTHON                                     │
│  ───────────────────────                                     │
│  - Ansible                                                   │
│  - AWS CLI / Boto3                                          │
│  - Fabric                                                   │
│  - SaltStack                                                │
│                                                              │
│  USE CASES                                                   │
│  ─────────                                                   │
│  - Provisionner des ressources cloud                        │
│  - Parser des logs                                          │
│  - Generer des configs                                      │
│  - Monitorer des services                                   │
│  - Interagir avec des APIs                                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## How - En pratique

### Installation

```bash
# Verifier Python
python3 --version

# Ubuntu/Debian
sudo apt install python3 python3-pip python3-venv

# macOS (deja installe, ou via Homebrew)
brew install python

# Verifier pip
pip3 --version
```

### Les bases

```python
# Variables
name = "DevOps"
count = 42
price = 19.99
is_active = True

# Types
type(name)     # <class 'str'>
type(count)    # <class 'int'>
type(price)    # <class 'float'>
type(is_active)  # <class 'bool'>

# Strings
message = "Hello"
message = 'Hello'
message = """Multi
line"""
message = f"Hello {name}"  # f-string (Python 3.6+)

# Operations string
text = "hello world"
text.upper()        # "HELLO WORLD"
text.lower()        # "hello world"
text.title()        # "Hello World"
text.split()        # ["hello", "world"]
text.replace("world", "python")  # "hello python"
len(text)           # 11
"hello" in text     # True

# Listes
servers = ["web1", "web2", "db1"]
servers[0]          # "web1"
servers[-1]         # "db1" (dernier)
servers[0:2]        # ["web1", "web2"]
servers.append("cache1")
servers.remove("web2")
len(servers)        # 3
"web1" in servers   # True

# Dictionnaires
server = {
    "name": "web-1",
    "ip": "192.168.1.10",
    "port": 8080,
    "active": True
}
server["name"]      # "web-1"
server.get("name")  # "web-1"
server.get("missing", "default")  # "default"
server["status"] = "running"  # Ajouter
server.keys()       # dict_keys(['name', 'ip', ...])
server.values()     # dict_values(['web-1', '192.168.1.10', ...])
server.items()      # dict_items([('name', 'web-1'), ...])

# Tuples (immutables)
coords = (10, 20)
x, y = coords       # Unpacking

# Sets (uniques)
tags = {"python", "devops", "automation"}
tags.add("cloud")
tags.remove("python")
```

### Conditions

```python
# If/elif/else
status = "running"

if status == "running":
    print("Server is up")
elif status == "stopped":
    print("Server is down")
else:
    print("Unknown status")

# Operateurs
# ==, !=, <, >, <=, >=
# and, or, not
# in, not in
# is, is not

if count > 10 and is_active:
    print("Active and many")

if "web" in server["name"]:
    print("It's a web server")

# Ternaire
message = "Up" if is_active else "Down"
```

### Boucles

```python
# For - liste
servers = ["web1", "web2", "db1"]

for server in servers:
    print(f"Processing {server}")

# For - avec index
for i, server in enumerate(servers):
    print(f"{i}: {server}")

# For - dictionnaire
for key, value in server.items():
    print(f"{key}: {value}")

# For - range
for i in range(5):       # 0, 1, 2, 3, 4
    print(i)

for i in range(1, 6):    # 1, 2, 3, 4, 5
    print(i)

for i in range(0, 10, 2):  # 0, 2, 4, 6, 8
    print(i)

# While
count = 0
while count < 5:
    print(count)
    count += 1

# Break et continue
for server in servers:
    if server == "db1":
        break       # Sort de la boucle
    if "web" not in server:
        continue    # Passe au suivant
    print(server)

# List comprehension
names = [s.upper() for s in servers]
active = [s for s in servers if "web" in s]
```

### Fonctions

```python
# Fonction basique
def greet(name):
    return f"Hello, {name}!"

result = greet("DevOps")

# Arguments par defaut
def connect(host, port=22, timeout=30):
    print(f"Connecting to {host}:{port}")

connect("192.168.1.10")
connect("192.168.1.10", 8080)
connect("192.168.1.10", port=443, timeout=60)

# *args et **kwargs
def deploy(*servers, **options):
    print(f"Servers: {servers}")
    print(f"Options: {options}")

deploy("web1", "web2", force=True, env="prod")

# Lambda
double = lambda x: x * 2
servers_upper = list(map(lambda s: s.upper(), servers))

# Docstring
def backup_database(db_name, destination):
    """
    Backup a database to a destination.

    Args:
        db_name: Name of the database
        destination: Backup destination path

    Returns:
        True if successful, False otherwise
    """
    # ...
    return True
```

### Classes (basics)

```python
class Server:
    def __init__(self, name, ip):
        self.name = name
        self.ip = ip
        self.status = "stopped"

    def start(self):
        self.status = "running"
        print(f"Starting {self.name}")

    def stop(self):
        self.status = "stopped"
        print(f"Stopping {self.name}")

    def __str__(self):
        return f"Server({self.name}, {self.ip})"

# Utilisation
web = Server("web-1", "192.168.1.10")
web.start()
print(web.status)
print(web)
```

### Gestion d'erreurs

```python
# Try/except
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")

# Multiple exceptions
try:
    data = open("file.txt").read()
except FileNotFoundError:
    print("File not found")
except PermissionError:
    print("Permission denied")
except Exception as e:
    print(f"Error: {e}")

# Finally
try:
    file = open("data.txt")
    data = file.read()
except FileNotFoundError:
    data = ""
finally:
    file.close()  # Toujours execute

# With (context manager)
with open("data.txt") as file:
    data = file.read()
# Fichier ferme automatiquement

# Raise
def validate_port(port):
    if not 1 <= port <= 65535:
        raise ValueError(f"Invalid port: {port}")
    return port
```

### Fichiers

```python
# Lire un fichier
with open("config.txt", "r") as file:
    content = file.read()       # Tout le contenu
    # ou
    lines = file.readlines()    # Liste de lignes

# Ecrire un fichier
with open("output.txt", "w") as file:
    file.write("Hello World\n")

# Append
with open("log.txt", "a") as file:
    file.write("New log entry\n")

# JSON
import json

# Lire JSON
with open("config.json") as file:
    config = json.load(file)

# Ecrire JSON
with open("output.json", "w") as file:
    json.dump(data, file, indent=2)

# JSON string
json_str = json.dumps(data)
data = json.loads(json_str)

# YAML (pip install pyyaml)
import yaml

with open("config.yaml") as file:
    config = yaml.safe_load(file)

with open("output.yaml", "w") as file:
    yaml.dump(data, file)
```

### Modules utiles

```python
# os - Systeme
import os

os.getcwd()                     # Current directory
os.listdir(".")                 # List files
os.path.exists("file.txt")      # Check exists
os.path.join("dir", "file.txt") # Join paths
os.makedirs("a/b/c", exist_ok=True)  # Create dirs
os.environ.get("HOME")          # Env variable
os.system("ls -la")             # Run command (basique)

# subprocess - Commandes
import subprocess

result = subprocess.run(
    ["ls", "-la"],
    capture_output=True,
    text=True
)
print(result.stdout)
print(result.returncode)

# Check output
output = subprocess.check_output(["hostname"]).decode().strip()

# sys - Python system
import sys

sys.argv        # Arguments CLI
sys.exit(1)     # Exit avec code
sys.path        # Python path

# datetime
from datetime import datetime, timedelta

now = datetime.now()
today = datetime.today()
timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
parsed = datetime.strptime("2024-01-15", "%Y-%m-%d")
tomorrow = now + timedelta(days=1)

# pathlib (moderne)
from pathlib import Path

path = Path("logs")
path.mkdir(exist_ok=True)
files = list(path.glob("*.log"))
content = Path("config.txt").read_text()
Path("output.txt").write_text("Hello")

# re - Regex
import re

pattern = r"\d{3}-\d{4}"
match = re.search(pattern, "Call 123-4567")
matches = re.findall(pattern, text)
replaced = re.sub(r"\s+", " ", text)
```

### Environnement virtuel

```bash
# Creer
python3 -m venv venv

# Activer
source venv/bin/activate    # Linux/Mac
venv\Scripts\activate       # Windows

# Installer des packages
pip install requests boto3 pyyaml

# Sauvegarder
pip freeze > requirements.txt

# Installer depuis requirements.txt
pip install -r requirements.txt

# Desactiver
deactivate
```

---

## Practice - Exercices

### Exercice 1: Script basique

```python
#!/usr/bin/env python3
"""Script pour lister les fichiers."""

import os
import sys

def list_files(directory, extension=None):
    """Liste les fichiers d'un repertoire."""
    files = []
    for item in os.listdir(directory):
        path = os.path.join(directory, item)
        if os.path.isfile(path):
            if extension is None or item.endswith(extension):
                files.append(item)
    return files

if __name__ == "__main__":
    directory = sys.argv[1] if len(sys.argv) > 1 else "."
    extension = sys.argv[2] if len(sys.argv) > 2 else None

    files = list_files(directory, extension)
    for f in files:
        print(f)
```

```bash
python list_files.py /var/log .log
```

### Exercice 2: Parser JSON

```python
#!/usr/bin/env python3
"""Parse un fichier JSON de config."""

import json
import sys

def load_config(filename):
    """Charge et valide une config."""
    with open(filename) as f:
        config = json.load(f)

    required = ["name", "port", "hosts"]
    for key in required:
        if key not in config:
            raise ValueError(f"Missing required key: {key}")

    return config

def main():
    if len(sys.argv) < 2:
        print("Usage: python parse_config.py <config.json>")
        sys.exit(1)

    try:
        config = load_config(sys.argv[1])
        print(f"App: {config['name']}")
        print(f"Port: {config['port']}")
        print(f"Hosts: {', '.join(config['hosts'])}")
    except FileNotFoundError:
        print(f"File not found: {sys.argv[1]}")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Invalid JSON: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### Exercice 3: Script avec argparse

```python
#!/usr/bin/env python3
"""Script avec arguments CLI."""

import argparse
import subprocess

def run_command(command, dry_run=False):
    """Execute une commande."""
    print(f"Command: {' '.join(command)}")
    if dry_run:
        print("(dry run - not executed)")
        return

    result = subprocess.run(command, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error: {result.stderr}")
    else:
        print(result.stdout)

def main():
    parser = argparse.ArgumentParser(description="Server management tool")
    parser.add_argument("action", choices=["start", "stop", "status"])
    parser.add_argument("--service", "-s", required=True, help="Service name")
    parser.add_argument("--dry-run", "-n", action="store_true", help="Dry run")
    parser.add_argument("--verbose", "-v", action="store_true")

    args = parser.parse_args()

    if args.verbose:
        print(f"Action: {args.action}")
        print(f"Service: {args.service}")

    command = ["systemctl", args.action, args.service]
    run_command(command, args.dry_run)

if __name__ == "__main__":
    main()
```

```bash
python manage.py start --service nginx --dry-run
python manage.py status -s nginx -v
```

---

## Cheatsheet

```
┌─────────────────────────────────────────────────────────────┐
│                        PYTHON                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  TYPES                                                       │
│  ─────                                                       │
│  str, int, float, bool                                      │
│  list, dict, tuple, set                                     │
│                                                              │
│  STRINGS                                                     │
│  ───────                                                     │
│  f"Hello {name}"        # f-string                          │
│  text.split()           # Split                             │
│  text.strip()           # Remove whitespace                 │
│  "sep".join(list)       # Join                              │
│                                                              │
│  LISTS                                                       │
│  ─────                                                       │
│  list.append(x)         # Add                               │
│  list.remove(x)         # Remove                            │
│  list[0]                # First                             │
│  list[-1]               # Last                              │
│  list[1:3]              # Slice                             │
│                                                              │
│  DICTS                                                       │
│  ─────                                                       │
│  dict["key"]            # Get                               │
│  dict.get("key", "def") # Get with default                  │
│  dict.items()           # Key-value pairs                   │
│                                                              │
│  CONTROL                                                     │
│  ───────                                                     │
│  if/elif/else                                               │
│  for x in list:                                             │
│  for i, x in enumerate(list):                               │
│  for k, v in dict.items():                                  │
│  while condition:                                           │
│                                                              │
│  FUNCTIONS                                                   │
│  ─────────                                                   │
│  def func(arg, default=val):                                │
│  def func(*args, **kwargs):                                 │
│  lambda x: x * 2                                            │
│                                                              │
│  FILES                                                       │
│  ─────                                                       │
│  with open("f") as f:                                       │
│      content = f.read()                                     │
│  json.load(f) / json.dump(data, f)                          │
│                                                              │
│  ERRORS                                                      │
│  ──────                                                      │
│  try: ... except Exception as e: ...                        │
│                                                              │
│  VENV                                                        │
│  ────                                                        │
│  python3 -m venv venv                                       │
│  source venv/bin/activate                                   │
│  pip install -r requirements.txt                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Interview Qs - Questions classiques

1. **Difference entre liste et tuple?**
   → Liste: mutable, peut etre modifiee. Tuple: immutable, plus rapide, utilise comme cle de dict.

2. **C'est quoi un environnement virtuel?**
   → Isolation des dependances par projet. Evite les conflits de versions.

3. **Difference entre `==` et `is`?**
   → `==` compare les valeurs. `is` compare les references (meme objet en memoire).

4. **C'est quoi un context manager?**
   → Gere les ressources (fichiers, connexions). `with` garantit le cleanup (`__enter__`, `__exit__`).

5. **C'est quoi `*args` et `**kwargs`?**
   → `*args`: arguments positionnels en tuple. `**kwargs`: arguments nommes en dict.

6. **List comprehension vs loop?**
   → Comprehension: plus concis, plus rapide. Loop: plus lisible pour logique complexe.

---

## Sujets lies

- **Apres:** [Python Scripting](/devops/python-automation) - Automatisation avancee
- **Lie:** [Ansible](/devops/ansible) - Ecrit en Python
- **Lie:** [AWS](/devops/aws) - Boto3 SDK Python

---

*Temps estime: 45 min lecture + 35 min pratique*
